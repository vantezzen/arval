 
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type TransformRule = {
  [k: string]: unknown;
} & {
  action: ActionEnum;
  subject: "rotation" | "scale" | "position";
  axes?: RotationAxes;
  /**
   * Upper and lower bounds for scale.
   *
   * @minItems 2
   * @maxItems 2
   */
  between?: [number, number];
  min?: number;
  max?: number;
  active?: boolean;
};
/**
 * Type of constraint (positive/negative).
 */
export type ActionEnum = "allow-only" | "forbid" | "require";
/**
 * 3D Axes (x, y, z).
 *
 * @minItems 1
 */
export type RotationAxes = ["x" | "y" | "z", ...("x" | "y" | "z")[]];
export type PlacementRuleOrGroup = PlacementRule | PlacementGroup;
export type PlacementGroup = {
  /**
   * @minItems 1
   */
  anyOf?: [PlacementRuleOrGroup, ...PlacementRuleOrGroup[]];
  /**
   * @minItems 1
   */
  allOf?: [PlacementRuleOrGroup, ...PlacementRuleOrGroup[]];
} & PlacementGroup1;
export type PlacementGroup1 = {
  [k: string]: unknown;
};

/**
 * Formal description for placement rules for AR-Objects in ARVal, supporting recursive boolean operations.
 */
export interface ConstraintSetWithBooleanOperations {
  /**
   * Human-readable name of the object (e.g. Tree)
   */
  name: string;
  /**
   * Tags associated with the object (e.g. tree, plantable, nature).
   *
   * @minItems 1
   */
  tags: [string, ...string[]];
  /**
   * Scope of the rules, must be 'object' for ACS.
   */
  scope: "object";
  /**
   * Transformation rules for placement, scale and rotation.
   */
  transform: TransformRule[];
  /**
   * Placement rules for the object.
   */
  placement: PlacementRuleOrGroup[];
}
export interface PlacementRule {
  action: ActionEnum;
  /**
   * Type of rule, e.g. 'distance'.
   */
  subject: string;
  /**
   * Human-readable reason for the rule.
   */
  reason: string;
  /**
   * Type of reason, either 'atomic' (short and combinable) or 'full' (long sentence).
   */
  reasonType?: "atomic" | "full";
  [k: string]: unknown;
}
